<template>
    <div className="h-full w-full flex flex-col p-4">
        <div class="flex items-center flex-end mb-2">
            <v-select v-model="selectedOption" label="name" class="h-9 text-primary-dark rounded w-60 mr-3"
                @click="() => loadJsonFiles()" :options="programs" @option:selected="onChangeFile()"></v-select>
            <button class="btn" @click="() => generateFlow()">Generate</button>
            <input id="program-name" className="hidden input mr-2" placeholder="Add program name"
                @input="addProgramName($event)" v-model="nodeProgramName" />
        </div>
        <div class="w-full h-full">
            <div class="drawflow-container border border-slate-400 rounded w-full h-full relative">
                <div id="drawflow">
                    <div>
                        <div v-if="action != 'add'" class="flex bg-primary-light w-fit text-white p-2 justify-center"
                            style="border-bottom-right-radius: 7px;">
                            <pre class="mr-1 my-0 p-0 flex items-center">{{ flowName }}</pre>

                        </div>
                    </div>
                </div>
                <a className="absolute m-2 right-0 top-0 cursor-pointer text-primary-dark hover:text-primary-light"
                    @click=" cleanEditor()" title="Press to clear">
                    <svg xmlns="http://www.w3.org/2000/svg" width="36" height="36" fill="currentColor"
                        class="bi bi-arrow-clockwise" viewBox="0 0 16 16">
                        <path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2v1z" />
                        <path
                            d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466z" />
                    </svg>
                </a>
            </div>
        </div>
    </div>
</template>

<script lang="ts">
import { h, getCurrentInstance, render } from 'vue'
import Drawflow from 'drawflow'
import Swal from 'sweetalert2'
import { SweetAlertIcon } from 'sweetalert2'
import ImportExcel from '../components/ImportExcel.vue'
import NodeFileInput from '../components/Node-file-input.vue'
import NodeStart from '../components/Node-start.vue'
import NodeEnd from '../components/Node-end.vue'
import NodeIf from '../components/Node-if.vue'
import NodeGeneratePdf from '../components/Node-GeneratePdf.vue'
import { nodesList } from '../utils/nodesList'
import { ipcRenderer } from 'electron';
import quillCSS from 'quill/dist/quill.snow.css'
import 'vue3-toastify/dist/index.css';

export default {
    name: "DrawflowDashboard",
    inject: ['ipcRenderer'],
    data() {
        return {
            selectedOption: null as any,
            programName: '' as string,
            action: 'add' as string,
            nodeProgramName: '' as string,
            flowName: null as any,
            programs: [] as any,
            editor: [] as any,
            node_select: '',
            node_last_move: null as any,
            nodesList: nodesList
        };
    },
    mounted() {
        const internalInstance: any = getCurrentInstance();
        internalInstance.appContext.app._context.config.globalProperties.$df = this.editor;
        const id: HTMLElement = document.getElementById("drawflow") || document.createElement('div');
        this.editor.value = new Drawflow(id, { version: 3, h, render }, internalInstance.appContext.app._context);
        this.editor.value.start();

        this.editor.value.registerNode("ImportExcel", ImportExcel, {}, {});
        this.editor.value.registerNode("file-input", NodeFileInput, {}, {});
        this.editor.value.registerNode("start", NodeStart, {}, {});
        this.editor.value.registerNode("end", NodeEnd, {}, {});
        this.editor.value.registerNode("Generatepdf", NodeGeneratePdf, {}, {});
        this.editor.value.registerNode("condition", NodeIf, {}, {});

    },
    methods: {
        touchScreenPosition(ev: any) {
            this.node_last_move = ev;
        }
        ,
        addNodeToDrawFlow(name: any, pos_x: any, pos_y: any) {
            pos_x = pos_x * (this.editor.value.precanvas.clientWidth / (this.editor.value.precanvas.clientWidth * this.editor.value.zoom)) - (this.editor.value.precanvas.getBoundingClientRect().x
                * (this.editor.value.precanvas.clientWidth / (this.editor.value.precanvas.clientWidth * this.editor.value.zoom)));
            pos_y = pos_y * (this.editor.value.precanvas.clientHeight / (this.editor.value.precanvas.clientHeight * this.editor.value.zoom)) - (this.editor.value.precanvas.getBoundingClientRect().y
                * (this.editor.value.precanvas.clientHeight / (this.editor.value.precanvas.clientHeight * this.editor.value.zoom)));
            const nodeSelected: any = nodesList.find(object => object.item === name);
            this.editor.value.addNode(name, nodeSelected.input, nodeSelected.output, pos_x, pos_y, name, { mytemplate: "", csv: "", headers: [], excelData: "", symbole: "", mypdf: "", myzip: "", varaible2: "" }, name, "vue");
        },
        addProgramName(event: any) {
            this.programName = event.target.value;
        },
        async loadJsonFiles() {
            const response = await ipcRenderer.invoke('getJsonFiles');
            this.programs = response;
        },
        async onChangeFile() {
            const selectedFile = this.selectedOption;
            this.action = "edit"
            this.flowName = selectedFile;
            const response = await ipcRenderer.invoke('getJsonFile', { name: selectedFile });
            const jsonData = JSON.parse(response);
            if (jsonData?.drawflow) {
                const dataa = jsonData.drawflow.Home.data;
                const ob = {
                    drawflow: {
                        Home: {
                            data: dataa
                        }
                    }
                };
                this.editor.value.import(ob);
            }
        },
        cleanEditor() {
            this.editor.value.clear();
        },
        /* Node generatePdf the path stored in the excelData
           The Data of the Excel file is retrieved from the NodeExcel and is stored in the excelData
           the Header option is retrieved from the NodeCondition and is stored in mytemplate
        */
        async generateFlow() {
            var idNode = parseFloat(this.getStartId());
            this.searchNodeEnd();
            if (idNode) {
                var dataNode = this.editor.value.getNodeFromId(idNode)
                var dataNodeStart = this.editor.value.getNodeFromId(idNode)
                var nameNode = dataNode.name;
                var startoutputs = 0;
                var headerCondition = [] as any;
                var dataExcel = [] as any;
                while (dataNodeStart.outputs?.output_1?.connections[startoutputs]) {
                    idNode = parseFloat(dataNodeStart.outputs.output_1.connections[startoutputs].node)
                    dataNode = this.editor.value.getNodeFromId(idNode)
                    nameNode = dataNode.name;
                    startoutputs = startoutputs + 1;
                    while (nameNode != "end") {
                        if (nameNode == "ImportExcel") {
                            dataExcel = dataNode.data.excelData;
                            idNode = parseFloat(dataNode.outputs?.output_1?.connections[0]?.node);
                            dataNode = this.editor.value.getNodeFromId(idNode);
                            nameNode = dataNode.name;
                            if (nameNode == "condition") {
                                var dataAccepted = [] as any;
                                var dataNotAccepted = [] as any;
                                while (nameNode != "end") {
                                    var dataOutput1 = dataNode;
                                    var dataOutput2 = dataNode;
                                    var idNodeoutput2 = 0;
                                    headerCondition = dataNode.data.mytemplate;
                                    for (var i = 0; i < dataExcel.length; i++) {
                                        var element = dataExcel[i];
                                        if (element[headerCondition] > 0) {
                                            dataAccepted.push(dataExcel[i]);
                                        } else {
                                            dataNotAccepted.push(dataExcel[i]);
                                        }
                                    }
                                    if (dataNode.outputs?.output_1?.connections[0]) {
                                        var idNodeoutput1 = parseFloat(dataOutput1.outputs.output_1.connections[0].node)
                                        dataOutput1 = this.editor.value.getNodeFromId(idNodeoutput1)
                                        var nameNodeOutput1 = dataOutput1.name;
                                        if (nameNodeOutput1 != "condition") {
                                            await this.generateNodePdf(nameNodeOutput1, dataAccepted, dataOutput1);
                                            nameNode = "end";
                                        }
                                    }
                                    if (dataNode.outputs?.output_2?.connections[0]) {
                                        idNodeoutput2 = parseFloat(dataOutput2.outputs?.output_2?.connections[0]?.node);
                                        dataOutput2 = this.editor.value.getNodeFromId(idNodeoutput2);
                                        var nameNodeOutput2 = dataOutput2.name;
                                        await this.generateNodePdf(nameNodeOutput2, dataNotAccepted, dataOutput2);
                                    }
                                    for (var i = 0; i < dataNotAccepted.length; i++) {
                                        var element = dataNotAccepted[i];
                                        var index = dataExcel.indexOf(element);
                                        if (index !== -1) {
                                            dataExcel.splice(index, 1);
                                        }
                                    }
                                    dataAccepted = [];
                                    dataNotAccepted = [];
                                    if (nameNode != "end") {
                                        idNode = parseFloat(dataNode.outputs?.output_1?.connections[0]?.node);
                                        if (idNode) {
                                            dataNode = this.editor.value.getNodeFromId(idNode);
                                        }
                                        nameNode = dataNode.name;
                                    }
                                }
                            }
                            this.showSucess();
                        }
                        if (nameNode == "Generatepdf") {
                            await this.generateNodePdf(nameNode, null, dataNode);
                        }
                        if (nameNode != "end") {
                            idNode = parseFloat(dataNode.outputs?.output_1?.connections[0]?.node);
                            if (idNode) {
                                dataNode = this.editor.value.getNodeFromId(idNode);
                            }
                            nameNode = dataNode.name;
                        }
                    }
                }
            }

        },
        async generateNodePdf(nameNodeOutput: any, dataExcel: any, dataOutput) {
            while (nameNodeOutput !== "end") {
                if (nameNodeOutput == "Generatepdf") {
                    var replacedResponse = "";
                    var response = "";
                    var lenghtData = 1;
                    const currentDate = new Date();
                    const currentYear = currentDate.getFullYear();
                    const currentDateStr = currentDate.toISOString().split('T')[0];
                    if (dataExcel) {
                        lenghtData = dataExcel.length;
                    }
                    for (var i = 0; i < lenghtData; i++) {
                        if (dataExcel) { var employee = dataExcel[i]; }
                        const idInput = parseFloat(dataOutput.inputs.input_1.connections[0].node)
                        if (idInput) {
                            const dataNodeinput = this.editor.value.getNodeFromId(idInput)
                            response = await ipcRenderer.invoke('getQuillContentData', { name: dataNodeinput.data.mytemplate });
                            if (response) {
                                if (dataExcel) {
                                    replacedResponse = this.replaceVariables(response, employee);
                                    if (dataExcel) {
                                        response = replacedResponse;
                                        response = response.replace(/{Name}/g, employee.Name);
                                        response = response.replace(/{DOC_YEAR}/g, "" + currentYear);
                                        response = response.replace(/{DOC_DATE}/g, currentDateStr);
                                        this.downloadPdf(response, employee.Name + "-" + currentDateStr, dataOutput.data.excelData + '/')

                                    }
                                }
                            }
                            else {
                                this.modalMessage('Error!', 'Something wrong.', 'error')
                            }
                        }
                    }
                    if (!dataExcel) {
                        this.downloadPdf(response, this.selectedOption + "-" + currentDateStr, dataOutput.data.excelData + '/')
                    }

                }
                var idNodeoutput = parseFloat(dataOutput.outputs?.output_1?.connections[0]?.node);
                dataOutput = this.editor.value.getNodeFromId(idNodeoutput);
                nameNodeOutput = dataOutput.name;
            }
        },
        replaceVariables(response, employee) {
            for (var prop in employee) {
                if (employee.hasOwnProperty(prop)) {
                    const variableName = `{${prop}}`;
                    const variableValue = employee[prop];
                    response = response.split(variableName).join(variableValue);
                }
            }
            return response;
        }
        ,
        searchNodeEnd() {
            const editorData = this.editor.value.export().drawflow.Home.data;
            let idEnd = "";
            Object.keys(editorData).forEach(function (i) {
                if (editorData[i].name === "end") {
                    idEnd = editorData[i].id;
                }
            });
            if (!idEnd) {
                this.modalMessage('Error!', 'To generate the flow, include at least one End node.', 'error')
            }
        },
        searchNodeGeneratepdf() {
            const editorData = this.editor.value.export().drawflow.Home.data;
            let variableName = "";
            Object.keys(editorData).forEach(function (i) {
                if (editorData[i].name === "Generatepdf") {
                    variableName = editorData[i].mytemplate;
                }
            });
            return variableName
        },
        getStartId() {
            const editorData = this.editor.value.export().drawflow.Home.data;
            let idStart = "";
            var numStart = 0;
            Object.keys(editorData).forEach(function (i) {
                if (editorData[i].name === "start") {
                    numStart++;
                    idStart = editorData[i].id;
                }
            });
            if (!idStart) {
                this.modalMessage('Error!', 'To generate the flow, include Start node.', 'error')
            }
            if (numStart > 1) {
                this.modalMessage('Error!', 'Include just one Start node.', 'error')
            }
            return idStart
        },
        async downloadPdf(htmlforpdf: any, namefile: any, path: any) {

            var name = namefile
            var html = '<html><head><style> footer{position: fixed;bottom: 0;}' + quillCSS + '</style></head><body><div class="ql-editor">' + htmlforpdf + ' <footer style="padding-top: 100px;"><div style="border-top: 2px solid gray;"><div style="font-size :15px; text-align:center; color:gray;margin-left:0px;margin-right:5px;"><p> NTT DATA Morocco Centers – SARL au capital de 7.700.000 Dhs – Parc Technologique de Tétouanshore, Route de Cabo Negro, Martil – Maroc – RC: 19687 – IF : 15294847 – CNSS : 4639532 – </br>Taxe Prof. :51840121</p></div></footer> </div></body></html>'
            var pdf = require('hm-html-pdf');
            var options = {
                format: 'A4',
                orientation: "portrait",
            };
            pdf.create(html, options).toFile(path + name + '.pdf', function (err, res) {
                if (err) return console.log(err);
                //console.log(res);
            });
        },
        showSucess() {
            Swal.fire({
                toast: true,
                icon: 'success',
                title: 'Your flow has been successfully generated!',
                position: 'bottom-left',
                timer: 2000,
                showConfirmButton: false,
                timerProgressBar: true,
            })
        },

        modalMessage(title: string, type: string, message: SweetAlertIcon) {
            Swal.fire(
                title,
                type,
                message
            );
        }
    }
}
</script>

<style scoped>
.node {
    @apply bg-primary-light border border-collapse text-white p-3 rounded w-full cursor-pointer sm:text-sm flex hover:bg-primary-dark hover:border hover:border-gray-800;
}

#drawflow {
    text-align: initial;
    width: 100%;
    height: 100%;
    background: #f1eeee;
    background-size: 20px 20px;
    background-image: radial-gradient(#c5c3c3 1px, transparent 1px);
}
</style>